"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setValueForStyles = exports.createDangerousStringForStyles = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var check_string_coercion_1 = require("@zenflux/react-shared/src/check-string-coercion");
var hyphenateStyleName_1 = require("@zenflux/react-dom-bindings/src/shared/hyphenateStyleName");
var warnValidStyle_1 = require("@zenflux/react-dom-bindings/src/shared/warnValidStyle");
var isUnitlessNumber_1 = require("@zenflux/react-dom-bindings/src/shared/isUnitlessNumber");
var CSSShorthandProperty_1 = require("@zenflux/react-dom-bindings/src/client/CSSShorthandProperty");
/**
 * Operations for dealing with CSS properties.
 */
/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
    if (__DEV__) {
        var serialized = "";
        var delimiter = "";
        for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
                continue;
            }
            var value = styles[styleName];
            if (value != null && typeof value !== "boolean" && value) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                if (isCustomProperty) {
                    if (__DEV__) {
                        (0, check_string_coercion_1.checkCSSPropertyStringCoercion)(value, styleName);
                    }
                    serialized += delimiter + styleName + ":" + ("" + value).trim();
                }
                else {
                    if (typeof value === "number" && value !== 0 && !(0, isUnitlessNumber_1.default)(styleName)) {
                        serialized += delimiter + (0, hyphenateStyleName_1.default)(styleName) + ":" + value + "px";
                    }
                    else {
                        if (__DEV__) {
                            (0, check_string_coercion_1.checkCSSPropertyStringCoercion)(value, styleName);
                        }
                        serialized += delimiter + (0, hyphenateStyleName_1.default)(styleName) + ":" + ("" + value).trim();
                    }
                }
                delimiter = ";";
            }
        }
        return serialized || null;
    }
}
exports.createDangerousStringForStyles = createDangerousStringForStyles;
function setValueForStyle(style, styleName, value) {
    var isCustomProperty = styleName.indexOf("--") === 0;
    if (__DEV__) {
        if (!isCustomProperty) {
            (0, warnValidStyle_1.default)(styleName, value);
        }
    }
    if (value == null || typeof value === "boolean" || value === "") {
        if (isCustomProperty) {
            style.setProperty(styleName, "");
        }
        else if (styleName === "float") {
            style.cssFloat = "";
        }
        else {
            style[styleName] = "";
        }
    }
    else if (isCustomProperty) {
        style.setProperty(styleName, value);
    }
    else if (typeof value === "number" && value !== 0 && !(0, isUnitlessNumber_1.default)(styleName)) {
        style[styleName] = value + "px"; // Presumes implicit 'px' suffix for unitless numbers
    }
    else {
        if (styleName === "float") {
            style.cssFloat = value;
        }
        else {
            if (__DEV__) {
                (0, check_string_coercion_1.checkCSSPropertyStringCoercion)(value, styleName);
            }
            style[styleName] = ("" + value).trim();
        }
    }
}
/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * // @param {DOMElement} node
 * // @param {object} styles
 */
function setValueForStyles(node, styles, prevStyles) {
    if (typeof styles !== "object") {
        throw new Error("The `style` prop expects a mapping from style properties to values, " + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + "using JSX.");
    }
    if (__DEV__) {
        if (styles) {
            // Freeze the next style object so that we can assume it won't be
            // mutated. We have already warned for this in the past.
            Object.freeze(styles);
        }
    }
    var style = node.style;
    if (prevStyles != null) {
        if (__DEV__) {
            validateShorthandPropertyCollisionInDev(prevStyles, styles);
        }
        for (var styleName in prevStyles) {
            if (prevStyles.hasOwnProperty(styleName) && (styles == null || !styles.hasOwnProperty(styleName))) {
                // Clear style
                var isCustomProperty = styleName.indexOf("--") === 0;
                if (isCustomProperty) {
                    style.setProperty(styleName, "");
                }
                else if (styleName === "float") {
                    style.cssFloat = "";
                }
                else {
                    // @ts-ignore
                    style[styleName] = "";
                }
            }
        }
        // Original code
        // for ( const styleName in styles ) {
        //     const value = styles[ styleName ];
        //
        //     if ( styles.hasOwnProperty( styleName ) && prevStyles[ styleName ] !== value ) {
        //         setValueForStyle( style, styleName, value );
        //     }
        // }
        Object.keys(styles).forEach(function (styleName) {
            var value = styles[styleName];
            if (styles.hasOwnProperty(styleName) && prevStyles[styleName] !== value) {
                setValueForStyle(style, styleName, value);
            }
        });
    }
    else {
        // Original code
        // for ( const styleName in styles ) {
        //     if ( styles.hasOwnProperty( styleName ) ) {
        //         const value = styles[ styleName ];
        //         setValueForStyle( style, styleName, value );
        //     }
        // }
        Object.keys(styles).forEach(function (styleName) {
            if (styles.hasOwnProperty(styleName)) {
                var value = styles[styleName];
                setValueForStyle(style, styleName, value);
            }
        });
    }
}
exports.setValueForStyles = setValueForStyles;
function isValueEmpty(value) {
    return value == null || typeof value === "boolean" || value === "";
}
/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */
function expandShorthandMap(styles) {
    var expanded = {};
    Object.keys(styles).forEach(function (key) {
        var longhand = CSSShorthandProperty_1.shorthandToLonghand[key] || [key];
        for (var i = 0; i < longhand.length; i++) {
            expanded[longhand[i]] = key;
        }
    });
    // Original code
    // for ( const key in styles ) {
    //     const longhands = shorthandToLonghand[ key ] || [ key ];
    //
    //     for ( let i = 0 ; i < longhands.length ; i++ ) {
    //         expanded[ longhands[ i ] ] = key;
    //     }
    // }
    return expanded;
}
/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */
function validateShorthandPropertyCollisionInDev(prevStyles, nextStyles) {
    if (__DEV__) {
        if (!nextStyles) {
            return;
        }
        // Compute the diff as it would happen elsewhere.
        var expandedUpdates_1 = {};
        if (prevStyles) {
            // Original code
            // for ( const prop in prevStyles ) {
            //     if ( prevStyles.hasOwnProperty( prop ) && ! nextStyles.hasOwnProperty( prop ) ) {
            //         const longhands = shorthandToLonghand[ prop ] || [ prop ];
            //
            //         for ( let i = 0 ; i < longhands.length ; i++ ) {
            //             expandedUpdates[ longhands[ i ] ] = prop;
            //         }
            //     }
            // }
            Object.keys(prevStyles).forEach(function (prop) {
                if (prevStyles.hasOwnProperty(prop) && !nextStyles.hasOwnProperty(prop)) {
                    var longhands = CSSShorthandProperty_1.shorthandToLonghand[prop] || [prop];
                    for (var i = 0; i < longhands.length; i++) {
                        expandedUpdates_1[longhands[i]] = prop;
                    }
                }
            });
        }
        // Original code
        // for ( const key in nextStyles ) {
        //     if ( nextStyles.hasOwnProperty( key ) && ( ! prevStyles || prevStyles[ key ] !== nextStyles[ key ] ) ) {
        //         const longhands = shorthandToLonghand[ key ] || [ key ];
        //
        //         for ( let i = 0 ; i < longhands.length ; i++ ) {
        //             expandedUpdates[ longhands[ i ] ] = key;
        //         }
        //     }
        // }
        Object.keys(nextStyles).forEach(function (key) {
            if (prevStyles.hasOwnProperty(key) && !nextStyles.hasOwnProperty(key)) {
                var longhands = CSSShorthandProperty_1.shorthandToLonghand[key] || [key];
                for (var i = 0; i < longhands.length; i++) {
                    expandedUpdates_1[longhands[i]] = key;
                }
            }
        });
        var expandedStyles_1 = expandShorthandMap(nextStyles);
        var warnedAbout_1 = {};
        // Original code
        // for ( const key in expandedUpdates ) {
        //     const originalKey = expandedUpdates[ key ];
        //     const correctOriginalKey = expandedStyles[ key ];
        //
        //     if ( correctOriginalKey && originalKey !== correctOriginalKey ) {
        //         const warningKey = originalKey + "," + correctOriginalKey;
        //
        //         if ( warnedAbout[ warningKey ] ) {
        //             continue;
        //         }
        //
        //         warnedAbout[ warningKey ] = true;
        //         console.error( "%s a style property during rerender (%s) when a " +
        //             "conflicting property is set (%s) can lead to styling bugs. To " + "avoid this, don't mix shorthand and non-shorthand properties " +
        //             "for the same value; instead, replace the shorthand with " +
        //             "separate values.",
        //             isValueEmpty( nextStyles[ originalKey ] as string ) ?
        //                 "Removing" : "Updating", originalKey, correctOriginalKey
        //         );
        //     }
        // }
        Object.keys(expandedUpdates_1).forEach(function (key) {
            var originalKey = expandedUpdates_1[key];
            var correctOriginalKey = expandedStyles_1[key];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout_1[warningKey]) {
                    return;
                }
                warnedAbout_1[warningKey] = true;
                console.error("%s a style property during rerender (%s) when a " +
                    "conflicting property is set (%s) can lead to styling bugs. To " + "avoid this, don't mix shorthand and non-shorthand properties " +
                    "for the same value; instead, replace the shorthand with " +
                    "separate values.", isValueEmpty(nextStyles[originalKey]) ?
                    "Removing" : "Updating", originalKey, correctOriginalKey);
            }
        });
    }
}
