/**
 * This a POC, made during the assignment, comments generated by github copilot.
 */
import commandsManager from "@zenflux/react-commander/commands-manager";

import { APIModuleBase } from "@zenflux/react-api/src/api-module-base.ts";

import { CHANNEL_LIST_STATE_DATA_WITH_META } from "@zenflux/app-budget-allocation/src/components/channel/channel-constants";

import { pickEnforcedKeys } from "@zenflux/app-budget-allocation/src/utils";

import type { APIComponent } from "@zenflux/react-api/src/api-component.tsx";

import type { DCommandFunctionComponent, DCommandSingleComponentContext } from "@zenflux/react-commander/definitions";

import type { APICore } from "@zenflux/react-api/src/api-core.tsx";

export class APIChannelsModule extends APIModuleBase {
    private channelsItemState: Record<string, any> = {};

    private lastChannelsItemState: Record<string, any> = {};
    private lastChannelsItemStateUpdated: Record<string, any> = {};

    private autosaveDebounceTimer: Timer | undefined;
    private autosaveHandler: ( ( immediate?: boolean ) => boolean ) | undefined;

    public constructor( api: APICore ) {
        super( api );

        this.registerEndpoints();

        this.initializeAutosaveHandler();

        const dataRescuerCallback = () => {
            console.log( "APIChannelsModule: dataRescuerCallback()", {
                autoSaveHandler: this.autosaveHandler,
                lastChannelsItemState: this.lastChannelsItemState,
            } );

            if ( this.autosaveHandler ) {
                // Save immediately when the page is closed.
                this.autosaveHandler( true );
            }

            if ( Object.keys( this.lastChannelsItemState ).length > 0 ) {
                return false;
            }

            return true;
        };

        window.onbeforeunload = function () {
            const result = dataRescuerCallback();

            if ( ! result ) {
                return "Changes you made may not be saved.";
            }

            return undefined;
        };
    }

    public static getName(): string {
        return "channels";
    }

    private registerEndpoints(): void {
        this.register( "GET", "App/ChannelsList", "v1/channels" );
        this.register( "GET", "App/ChannelItem", "v1/channels/:key" );
        this.register( "POST", "App/ChannelItem", "v1/channels/:key" );
    }

    protected async requestHandler( component: APIComponent, element: DCommandFunctionComponent, request: any ): Promise<any> {
        return request;
    }

    protected async responseHandler( component: APIComponent, element: DCommandFunctionComponent, response: Response ): Promise<any> {
        const result = await response.json();

        return this.handleResponseBasedOnElementName( element.getName!(), result, component );
    }

    // Handle the mounting of the component. This involves different handling depending on the component name.
    protected onMount( component: APIComponent, context: DCommandSingleComponentContext ) {
        switch ( context.componentName ) {
            case "App/ChannelsList":
                this.onChannelsListMount( component, context );
                break;
            case "App/ChannelItem":
                this.onChannelItemMount( component, context );
                break;
            default:
                throw new Error( `APIChannelsModule: onMount() - Unknown component: ${ context.componentName }` );
        }
    }

    protected onUnmount( component: APIComponent, context: DCommandSingleComponentContext ) {
        switch ( context.componentName ) {
            case "App/ChannelsList":
                this.onChannelsListUnmount( component, context );
                break;
            case "App/ChannelItem":
                this.onChannelItemUnmount( component, context );
                break;
            default:
                throw new Error( `APIChannelsModule: onUnmount() - Unknown component: ${ context.componentName }` );
        }
    }

    // Handle the updating of the component. This involves different handling depending on the component name.
    protected onUpdate( component: APIComponent, context: DCommandSingleComponentContext, state: {
        currentState: any,
        prevState: any,
        currentProps: any
    } ) {
        const { currentState, prevState } = state;
        switch ( context.componentName ) {
            case "App/ChannelsList":
                if ( currentState.channels !== prevState.channels ) {
                    this.onChannelsChanged( prevState.channels, currentState.channels );
                }
                break;
            case "App/ChannelItem":
                this.channelsItemState[ state.currentProps.meta.id ] = state;
                this.lastChannelsItemState[ state.currentProps.meta.id ] = state;
                break;
            default:
                throw new Error( `APIChannelsModule: onUpdate() - Unknown component: ${ context.componentName }` );
        }
    }

    private initializeAutosaveHandler() {
        if ( ! this.autosaveHandler ) {
            this.autosaveHandler = ( immediate?: boolean ) => {
                if ( immediate ) {
                    this.saveChannels();
                    return true;
                } else {
                    this.autoSaveChannels();
                }

                return false;
            };

            setInterval( () => {
                this.autosaveHandler?.();
            }, 5000 );
        }
    }

    // Handle the API response based on the element name. This allows different handling for different types of responses.
    private handleResponseBasedOnElementName( elementName: string, result: any, component: APIComponent ) {
        switch ( elementName ) {
            case "App/ChannelsList":
                return this.handleChannelsListResponse( result, component );
            case "App/ChannelItem":
                return this.handleChannelItemResponse( result );
            default:
                return result;
        }
    }

    // Handle the response for the channels list. This involves mapping over the result and creating a new object for each item.
    private handleChannelsListResponse( result: any, component: APIComponent ) {
        return {
            children: result.map( ( i: any ) => {
                const key = i.key;
                delete i.key;
                return {
                    key,
                    props: i,
                    type: component.props.children!.props.type,
                };
            } ),
        };
    }

    // Handle the response for an individual channel item. This involves creating a new object with the key and breaks properties modified.
    private handleChannelItemResponse( result: any ) {
        if ( result.breaks ) {
            result.breaks = result.breaks.map( ( i: any ) => ( {
                ... i,
                date: new Date( i.date ),
            } ) );
        }
        return result;
    }

    // Handle the mounting of the channels list. This involves setting up a timer to auto save channels every 5 seconds.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    private onChannelsListMount( component: APIComponent, context: DCommandSingleComponentContext ) {
        const commands = commandsManager.get( "UI/Accordion", true );

        if ( ! commands ) return;

        const onSelectionAttached = commands[ "UI/Accordion/onSelectionAttached" ],
            onSelectionDetached = commands[ "UI/Accordion/onSelectionDetached" ];

        const saveChannelsCallback = () => {
            this.autoSaveChannels();
        };

        onSelectionAttached.global().globalHook( saveChannelsCallback );
        onSelectionDetached.global().globalHook( saveChannelsCallback );
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    private onChannelsListUnmount( component: APIComponent, context: DCommandSingleComponentContext ) {
        // Save immediately when the channels list is unmounted.
        this.saveChannels();

        const commands = commandsManager.get( "UI/Accordion", true );

        if ( ! commands ) return;

        const onSelectionAttached = commands[ "UI/Accordion/onSelectionAttached" ],
            onSelectionDetached = commands[ "UI/Accordion/onSelectionDetached" ];

        onSelectionAttached.global().globalUnhook();
        onSelectionDetached.global().globalUnhook();
    }

    // Handle the mounting of an individual channel item. This involves fetching the channel data from the API and updating the state if necessary.
    private async onChannelItemMount( component: APIComponent, context: DCommandSingleComponentContext ) {
        // if ( Object.keys( this.channelsItemState ).length === 0 ) return;

        const key = context.props.meta.id;

        try {
            const apiData = await this.fetchAPIGetChannel( key );

            // Set current for next code execution.
            this.channelsItemState[ key ] = {
                currentProps: context.props,
                currentState: context.getState(),
            };

            if ( context.isMounted() && this.shouldUpdateStateFromRemote( apiData, key, context ) ) {
                this.updateStateFromRemote( apiData, context );
            }

        } catch ( error ) {
            console.warn( "An error occurred while fetching API data, the state will not be updated, this area considered to be safe", error );
        }
    }

    private async onChannelItemUnmount( component: APIComponent, context: DCommandSingleComponentContext ) {
        // If state is the same as the last known state, then it is safe to remove it.
        if ( Object.values( this.lastChannelsItemStateUpdated ).find( l => l === context.getState() ) ) {
            delete this.lastChannelsItemState[ context.props.meta.id ];
            delete this.lastChannelsItemStateUpdated[ context.props.meta.id ];

            return;
        }

        this.autosaveHandler?.( true );
    }

    // Handle when the channels change. This involves comparing the previous and current channels and updating the meta data if necessary.
    private onChannelsChanged( prevChannels: any[], currentChannels: any[] ) {
        for ( let i = 0 ; i < currentChannels.length ; i++ ) {
            if ( ! prevChannels[ i ] || ! currentChannels[ i ] ) continue;
            if ( prevChannels[ i ].props.meta !== currentChannels[ i ].props.meta ) {
                this.onChannelsMetaDataChanged(
                    currentChannels[ i ].props.meta.id!,
                    currentChannels[ i ].props.meta,
                    prevChannels[ i ].props.meta
                );
            }
        }

        const prevKeys = prevChannels.map( channel => channel.props.meta.id );
        const currentKeys = currentChannels.map( channel => channel.props.meta.id );

        const addedKeys = currentKeys.filter( key => ! prevKeys.includes( key ) );

        for ( const key of addedKeys ) {
            const newChannel = currentChannels.find( channel => channel.props.meta.id === key );

            if ( newChannel && newChannel.props && newChannel.props.meta ) {
                this.onChannelAdded( newChannel );
            }
        }
        if ( addedKeys.length > 0 ) {
            return;
        }

        const removedKeys = prevKeys.filter( key => ! currentKeys.includes( key ) );
        for ( const key of removedKeys ) {
            this.onChannelRemoved( key );
        }
        if ( removedKeys.length > 0 ) {
            return;
        }
    }

    private onChannelAdded( newChannel: any ) {
        // Send a POST request to the API to create the new channel
        this.api.fetch( "POST", "v1/channels/:key", {
            key: newChannel.props.meta.id,
            meta: newChannel.props.meta,
        }, ( r: {
            json: () => any;
        } ) => r.json() );
    }

    private onChannelRemoved( key: string ) {
        this.api.fetch( "DELETE", `v1/channels/${ key }`, {}, ( r: { json: () => any; } ) => r.json() ).then( () => {

            delete this.channelsItemState[ key ];

            // Safe removed.
            delete this.lastChannelsItemState[ key ];
        } );
    }

    // Handle when the meta data of a channel changes. This involves sending a POST request to the API with the new meta data.
    private onChannelsMetaDataChanged( key: string, currentMeta: any, _prevMeta: any ) {
        if ( this.channelsItemState[ key ]?.currentState?.meta ) {
            this.channelsItemState[ key ].currentState.meta = currentMeta;
        }

        if ( this.lastChannelsItemState[ key ]?.currentState?.meta ) {
            this.lastChannelsItemState[ key ].currentState.meta = currentMeta;
        }

        this.api.fetch( "POST", "v1/channels/:key", { key, meta: currentMeta }, ( r: {
            json: () => any;
        } ) => r.json() );
    }

    private async autoSaveChannels(): Promise<true> {
        if ( this.autosaveDebounceTimer ) {
            clearTimeout( this.autosaveDebounceTimer );
        }

        // This will ensure that the channels are saved once per x requests during the debounce period.
        return new Promise( ( resolve ) => {
            this.autosaveDebounceTimer = setTimeout( () => {
                this.saveChannels();
                resolve( true );
            }, 800 );
        } );
    }

    // Save the channels. This involves finding all the channel item contexts and sending a POST request to the API with the state of each channel.
    private saveChannels() {
        const lastKnownStates = Object.values( this.lastChannelsItemState );

        if ( ! lastKnownStates.length ) return;

        try {
            console.log( "APIChannelsModule: saveChannels()" );

            lastKnownStates.forEach( ( state: any ) => {
                const key = (state.props || state.currentProps).meta.id;

                const stateToSave = pickEnforcedKeys( { ... state.currentProps, ... state.currentState },
                    CHANNEL_LIST_STATE_DATA_WITH_META
                );

                console.log( "APIChannelsModule: saveChannels() - stateToSave", stateToSave );

                this.api.fetch( "POST", "v1/channels/:key", { key, ... stateToSave }, ( _r: {
                    json: () => any;
                } ) => {
                    this.lastChannelsItemStateUpdated[ key ] = stateToSave;

                    delete this.lastChannelsItemState[ key ];
                } );

            } );
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch ( error ) {
            this.autosaveHandler?.();
        }
    }

    // Update the state with the data from the API.
    private updateStateFromRemote( apiData: any, context: DCommandSingleComponentContext ) {
        console.log( "%c APIChannelsModule: updateStateFromRemote()", "font-weight:bold;", apiData );

        if ( apiData.breaks ) {
            apiData.breaks = apiData.breaks.map( ( i: any ) => ( {
                ... i,
                date: new Date( i.date ),
            } ) );
        }

        context.setState( apiData );
    }

    // Determine whether the state should be updated. This involves comparing the current state with the data from the API.
    private shouldUpdateStateFromRemote( apiData: any, key: string, context: DCommandSingleComponentContext ) {
        const currentItemState = this.channelsItemState[ key ];

        // If the current item state is not available, then you cannot update the state.
        if ( ! currentItemState.currentProps ) return false;

        const vdom = pickEnforcedKeys( { ... currentItemState.currentProps, ... context.getState() },
            CHANNEL_LIST_STATE_DATA_WITH_META
        );

        const api = pickEnforcedKeys( apiData, CHANNEL_LIST_STATE_DATA_WITH_META );

        return JSON.stringify( vdom ) !== JSON.stringify( api );
    }

    // Fetch the channel data from the API.
    private async fetchAPIGetChannel( key: string ) {
        return await this.api.fetch( "GET", `v1/channels/${ key }`, {}, ( res: { json: () => any; } ) => res.json() );
    }
}

